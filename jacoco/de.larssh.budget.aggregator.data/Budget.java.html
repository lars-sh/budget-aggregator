<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Budget.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Budget Aggregator</a> &gt; <a href="index.source.html" class="el_package">de.larssh.budget.aggregator.data</a> &gt; <span class="el_source">Budget.java</span></div><h1>Budget.java</h1><pre class="source lang-java linenums">// Generated by delombok at Tue Jun 10 01:56:18 UTC 2025
package de.larssh.budget.aggregator.data;

import static java.util.Collections.emptySet;
import static java.util.Collections.unmodifiableMap;
import java.math.BigDecimal;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.poi.ss.util.CellReference;
import de.larssh.budget.aggregator.sheets.Row;
import de.larssh.budget.aggregator.sheets.Sheet;
import de.larssh.budget.aggregator.sheets.csv.CsvFiles;
import de.larssh.utils.text.Patterns;
import de.larssh.utils.text.StringParseException;
import de.larssh.utils.text.Strings;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * In German: Haushalt
 */
@SuppressWarnings(&quot;PMD.GodClass&quot;)
public final class Budget implements Comparable&lt;Budget&gt; {
<span class="nc" id="L35">	private static final Pattern BUDGET_HEADER_PATTERN = Pattern.compile(&quot;^\\s*(?&lt;budgetType&gt;.+?)\\s*((?&lt;year&gt;\\d+)|(?&lt;yearBefore&gt;Vorjahr))?\\s*$&quot;);</span>
<span class="nc" id="L36">	private static final Comparator&lt;Budget&gt; COMPARATOR = Comparator.&lt;Budget&gt;comparingInt(Budget::getYear).thenComparing(Budget::getType);</span>

	@SuppressWarnings({&quot;checkstyle:XIllegalCatchDefault&quot;, &quot;PMD.AvoidCatchingGenericException&quot;, &quot;PMD.ShortMethodName&quot;})
	@SuppressFBWarnings(value = &quot;WEM_WEAK_EXCEPTION_MESSAGING&quot;, justification = &quot;false-positive, using StringFormatter here&quot;)
	public static Set&lt;Budget&gt; of(final Sheet sheet) throws StringParseException {
<span class="nc" id="L41">		final int lastNonBalanceColumn = sheet.getHeader().indexOf(CsvFiles.COLUMN_NAME_ACCOUNT);</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">		if (lastNonBalanceColumn == -1) {</span>
<span class="nc" id="L43">			return emptySet();</span>
		}
<span class="nc" id="L45">		final boolean applyBudgetTypeSign = sheet.isApplyBudgetTypeSign();</span>
<span class="nc" id="L46">		final Map&lt;Budget, Budget&gt; budgets = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">		for (final Row row : sheet.getRows()) {</span>
			try {
<span class="nc" id="L49">				final Optional&lt;Account&gt; account = Account.of(row);</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">				if (account.isPresent()) {</span>
<span class="nc bnc" id="L51" title="All 4 branches missed.">					final boolean negate = applyBudgetTypeSign &amp;&amp; account.get().getType().getSign() &lt; 0;</span>
<span class="nc" id="L52">					final int headerSize = sheet.getHeader().size();</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">					for (int columnIndex = lastNonBalanceColumn + 1; columnIndex &lt; headerSize; columnIndex += 1) {</span>
<span class="nc" id="L54">						addBalance(budgets, account.get(), negate, row, sheet, columnIndex);</span>
					}
				}
<span class="nc" id="L57">			} catch (final Exception e) {</span>
<span class="nc" id="L58">				throw new StringParseException(e, &quot;Failed reading row %d.&quot;, row.getRowIndex());</span>
<span class="nc" id="L59">			}</span>
<span class="nc" id="L60">		}</span>
<span class="nc" id="L61">		return budgets.keySet();</span>
	}

	@SuppressWarnings(&quot;PMD.CompareObjectsWithEquals&quot;)
	private static void addBalance(final Map&lt;Budget, Budget&gt; budgets, final Account account, final boolean negate, final Row row, final Sheet sheet, final int columnIndex) {
<span class="nc" id="L66">		final String cellValue = row.get(columnIndex).orElse(null);</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">		if (Strings.isBlank(cellValue)) {</span>
<span class="nc" id="L68">			return;</span>
		}
<span class="nc" id="L70">		final Optional&lt;Matcher&gt; columnHeaderMatcher = Optional.ofNullable(sheet.getHeader().get(columnIndex)).flatMap(title -&gt; Patterns.matches(BUDGET_HEADER_PATTERN, title));</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">		if (!columnHeaderMatcher.isPresent()) {</span>
<span class="nc" id="L72">			return;</span>
		}
<span class="nc" id="L74">		final OptionalInt year = determineYear(row, columnHeaderMatcher.get());</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">		if (!year.isPresent()) {</span>
<span class="nc" id="L76">			return;</span>
		}
<span class="nc" id="L78">		final BudgetType budgetType = BudgetType.of(columnHeaderMatcher.get().group(&quot;budgetType&quot;));</span>
<span class="nc" id="L79">		final Budget newBudget = new Budget(year.getAsInt(), budgetType);</span>
<span class="nc" id="L80">		final Budget budget = budgets.computeIfAbsent(newBudget, Function.identity());</span>
<span class="nc" id="L81">		final Balance balance = new Balance(account, determineValue(cellValue, negate));</span>
<span class="nc" id="L82">		budget.balances.put(account, balance);</span>
		// Add References
<span class="nc bnc" id="L84" title="All 2 branches missed.">		if (budget == newBudget) {</span>
<span class="nc" id="L85">			sheet.getHeaderReferences().get(columnIndex).entrySet().forEach(entry -&gt; budget.setReferenceIfAbsent(entry.getKey(), entry.getValue()));</span>
		}
<span class="nc" id="L87">		row.get(CsvFiles.COLUMN_NAME_BUDGET_YEAR).ifPresent(y -&gt; budget.setReferenceIfAbsent(BudgetReference.BUDGET_YEAR, y));</span>
<span class="nc" id="L88">		budget.setReferenceIfAbsent(BudgetReference.COLUMN, CellReference.convertNumToColString(columnIndex));</span>
<span class="nc" id="L89">	}</span>

	@SuppressFBWarnings(value = &quot;OCP_OVERLY_CONCRETE_PARAMETER&quot;, justification = &quot;only valid for Java 20 and later&quot;)
	private static OptionalInt determineYear(final Row row, final Matcher columnHeaderMatcher) {
<span class="nc" id="L93">		final String year = columnHeaderMatcher.group(&quot;year&quot;);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">		if (year != null) {</span>
<span class="nc" id="L95">			return OptionalInt.of(Integer.parseInt(year));</span>
		}
<span class="nc" id="L97">		final Optional&lt;String&gt; yearCell = row.get(CsvFiles.COLUMN_NAME_BUDGET_YEAR);</span>
<span class="nc bnc" id="L98" title="All 4 branches missed.">		if (!yearCell.isPresent() || Strings.isBlank(yearCell.get())) {</span>
<span class="nc" id="L99">			return OptionalInt.empty();</span>
		}
<span class="nc bnc" id="L101" title="All 2 branches missed.">		final int offsetYears = columnHeaderMatcher.group(&quot;yearBefore&quot;) == null ? 0 : -1;</span>
<span class="nc" id="L102">		return OptionalInt.of(Integer.parseInt(yearCell.get()) + offsetYears);</span>
	}

	private static BigDecimal determineValue(final String cellValue, final boolean negate) {
<span class="nc" id="L106">		final BigDecimal number = new BigDecimal(cellValue);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">		return negate ? number.negate() : number;</span>
	}

	private final int year;
	private final BudgetType type;
	private final Map&lt;Account, Balance&gt; balances = new TreeMap&lt;&gt;();
	private final Map&lt;BudgetReference, String&gt; references = new EnumMap&lt;&gt;(BudgetReference.class);
	private boolean modifiable = true;

	@Override
	public int compareTo(@Nullable final Budget other) {
<span class="nc" id="L118">		return COMPARATOR.compare(this, other);</span>
	}

	public boolean equalsIncludingBalances(final Budget other) {
<span class="nc bnc" id="L122" title="All 6 branches missed.">		return equals(other) &amp;&amp; containsBalances(other) &amp;&amp; other.containsBalances(this);</span>
	}

	private boolean containsBalances(final Budget other) {
<span class="nc bnc" id="L126" title="All 2 branches missed.">		for (final Entry&lt;Account, Balance&gt; entry : other.getBalances().entrySet()) {</span>
<span class="nc" id="L127">			final BigDecimal otherValue = entry.getValue().getValue();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">			if (otherValue.compareTo(BigDecimal.ZERO) != 0) {</span>
<span class="nc" id="L129">				final Balance thisBalance = getBalances().get(entry.getKey());</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">				if (thisBalance != null &amp;&amp; thisBalance.getValue().compareTo(otherValue) != 0) {</span>
<span class="nc" id="L131">					return false;</span>
				}
			}
<span class="nc" id="L134">		}</span>
<span class="nc" id="L135">		return true;</span>
	}

	public Map&lt;Account, Balance&gt; getBalances() {
<span class="nc bnc" id="L139" title="All 2 branches missed.">		return modifiable ? balances : unmodifiableMap(balances);</span>
	}

	public Map&lt;BudgetReference, String&gt; getReferences() {
<span class="nc" id="L143">		return unmodifiableMap(references);</span>
	}

	public int removeEmptyBalances() {
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (!modifiable) {</span>
<span class="nc" id="L148">			throw new UnsupportedOperationException();</span>
		}
<span class="nc" id="L150">		int count = 0;</span>
<span class="nc" id="L151">		final Iterator&lt;Balance&gt; iterator = getBalances().values().iterator();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">		while (iterator.hasNext()) {</span>
<span class="nc" id="L153">			final Balance balance = iterator.next();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">			if (balance.getValue().compareTo(BigDecimal.ZERO) == 0) {</span>
<span class="nc" id="L155">				iterator.remove();</span>
<span class="nc" id="L156">				count += 1;</span>
			}
<span class="nc" id="L158">		}</span>
<span class="nc" id="L159">		return count;</span>
	}

	public void setReferenceIfAbsent(final BudgetReference reference, final String value) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">		if (!modifiable) {</span>
<span class="nc" id="L164">			throw new UnsupportedOperationException();</span>
		}
<span class="nc" id="L166">		references.putIfAbsent(reference, value);</span>
<span class="nc" id="L167">	}</span>

	public Budget unmodifiable() {
<span class="nc" id="L170">		modifiable = false;</span>
<span class="nc" id="L171">		return this;</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public int getYear() {
		return this.year;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public BudgetType getType() {
		return this.type;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public boolean isModifiable() {
		return this.modifiable;
	}

	@edu.umd.cs.findbugs.annotations.NonNull
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public java.lang.String toString() {
		return &quot;Budget(year=&quot; + this.getYear() + &quot;, type=&quot; + this.getType() + &quot;, references=&quot; + this.getReferences() + &quot;, modifiable=&quot; + this.isModifiable() + &quot;)&quot;;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public boolean equals(@edu.umd.cs.findbugs.annotations.Nullable final java.lang.Object o) {
		if (o == this) return true;
		if (!(o instanceof Budget)) return false;
		final Budget other = (Budget) o;
		if (this.getYear() != other.getYear()) return false;
		final java.lang.Object this$type = this.getType();
		final java.lang.Object other$type = other.getType();
		if (this$type == null ? other$type != null : !this$type.equals(other$type)) return false;
		return true;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		result = result * PRIME + this.getYear();
		final java.lang.Object $type = this.getType();
		result = result * PRIME + ($type == null ? 43 : $type.hashCode());
		return result;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Budget(final int year, final BudgetType type) {
		this.year = year;
		this.type = type;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>