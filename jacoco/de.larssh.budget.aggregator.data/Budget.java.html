<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Budget.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Budget Aggregator</a> &gt; <a href="index.source.html" class="el_package">de.larssh.budget.aggregator.data</a> &gt; <span class="el_source">Budget.java</span></div><h1>Budget.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Jun 09 20:43:29 UTC 2025
package de.larssh.budget.aggregator.data;

import static java.util.Collections.emptySet;
import static java.util.Collections.unmodifiableMap;
import java.math.BigDecimal;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.poi.ss.util.CellReference;
import de.larssh.budget.aggregator.file.CsvFiles;
import de.larssh.utils.Nullables;
import de.larssh.utils.text.Csv;
import de.larssh.utils.text.CsvRow;
import de.larssh.utils.text.Patterns;
import de.larssh.utils.text.StringParseException;
import de.larssh.utils.text.Strings;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

/**
 * In German: Haushalt
 */
@SuppressWarnings(&quot;PMD.GodClass&quot;)
public final class Budget implements Comparable&lt;Budget&gt; {
<span class="nc" id="L36">	private static final Pattern BUDGET_HEADER_PATTERN = Pattern.compile(&quot;^\\s*(?&lt;budgetType&gt;.+?)\\s*((?&lt;year&gt;\\d+)|(?&lt;yearBefore&gt;Vorjahr))?\\s*$&quot;);</span>
<span class="nc" id="L37">	private static final Comparator&lt;Budget&gt; COMPARATOR = Comparator.&lt;Budget&gt;comparingInt(Budget::getYear).thenComparing(Budget::getType);</span>

	@SuppressWarnings({&quot;checkstyle:XIllegalCatchDefault&quot;, &quot;PMD.AvoidCatchingGenericException&quot;, &quot;PMD.LooseCoupling&quot;, &quot;PMD.ShortMethodName&quot;})
	@SuppressFBWarnings(value = &quot;WEM_WEAK_EXCEPTION_MESSAGING&quot;, justification = &quot;false-positive, using StringFormatter here&quot;)
	public static Set&lt;Budget&gt; of(final Csv csv) throws StringParseException {
<span class="nc" id="L42">		final int lastNonBalanceColumn = csv.getHeaders().indexOf(CsvFiles.HEADER_ACCOUNT);</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">		if (lastNonBalanceColumn == -1) {</span>
<span class="nc" id="L44">			return emptySet();</span>
		}
<span class="nc" id="L46">		final Map&lt;Budget, Budget&gt; budgets = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">		for (final CsvRow row : csv.subList(1, csv.size())) {</span>
			try {
<span class="nc" id="L49">				final Optional&lt;Account&gt; account = Account.of(row);</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">				if (account.isPresent()) {</span>
<span class="nc" id="L51">					final int headerSize = csv.getHeaders().size();</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">					for (int columnIndex = lastNonBalanceColumn + 1; columnIndex &lt; headerSize; columnIndex += 1) {</span>
<span class="nc" id="L53">						addBalance(budgets, account.get(), row, columnIndex);</span>
					}
				}
<span class="nc" id="L56">			} catch (final Exception e) {</span>
<span class="nc" id="L57">				throw new StringParseException(e, &quot;Failed reading row %d.&quot;, row.getRowIndex());</span>
<span class="nc" id="L58">			}</span>
<span class="nc" id="L59">		}</span>
<span class="nc" id="L60">		return budgets.keySet();</span>
	}

	@SuppressWarnings(&quot;PMD.LooseCoupling&quot;)
	private static void addBalance(final Map&lt;Budget, Budget&gt; budgets, final Account account, final CsvRow row, final int columnIndex) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">		if (columnIndex &gt;= row.size()) {</span>
<span class="nc" id="L66">			return;</span>
		}
<span class="nc" id="L68">		final String cellValue = Nullables.orElseThrow(row.get(columnIndex));</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (Strings.isBlank(cellValue)) {</span>
<span class="nc" id="L70">			return;</span>
		}
<span class="nc" id="L72">		final String title = row.getCsv().getHeaders().get(columnIndex);</span>
<span class="nc" id="L73">		final Optional&lt;Matcher&gt; columnHeaderMatcher = Patterns.matches(BUDGET_HEADER_PATTERN, title);</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		if (!columnHeaderMatcher.isPresent()) {</span>
<span class="nc" id="L75">			return;</span>
		}
<span class="nc" id="L77">		final OptionalInt year = determineYear(row, columnHeaderMatcher.get());</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">		if (!year.isPresent()) {</span>
<span class="nc" id="L79">			return;</span>
		}
<span class="nc" id="L81">		final BudgetType budgetType = BudgetType.of(columnHeaderMatcher.get().group(&quot;budgetType&quot;));</span>
<span class="nc" id="L82">		final Budget budget = new Budget(year.getAsInt(), budgetType);</span>
<span class="nc" id="L83">		row.get(CsvFiles.HEADER_BUDGET_YEAR).ifPresent(y -&gt; budget.setReference(BudgetReference.BUDGET_YEAR, y));</span>
<span class="nc" id="L84">		budget.setReference(BudgetReference.COLUMN, CellReference.convertNumToColString(columnIndex));</span>
<span class="nc" id="L85">		final Balance balance = new Balance(account, determineValue(cellValue, account));</span>
<span class="nc" id="L86">		budgets.computeIfAbsent(budget, Function.identity()).balances.put(account, balance);</span>
<span class="nc" id="L87">	}</span>

	@SuppressWarnings(&quot;PMD.LooseCoupling&quot;)
	@SuppressFBWarnings(value = &quot;OCP_OVERLY_CONCRETE_PARAMETER&quot;, justification = &quot;only valid for Java 20 and later&quot;)
	private static OptionalInt determineYear(final CsvRow row, final Matcher columnHeaderMatcher) {
<span class="nc" id="L92">		final String year = columnHeaderMatcher.group(&quot;year&quot;);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">		if (year != null) {</span>
<span class="nc" id="L94">			return OptionalInt.of(Integer.parseInt(year));</span>
		}
<span class="nc" id="L96">		final Optional&lt;String&gt; yearCell = row.get(CsvFiles.HEADER_BUDGET_YEAR);</span>
<span class="nc bnc" id="L97" title="All 4 branches missed.">		if (!yearCell.isPresent() || Strings.isBlank(yearCell.get())) {</span>
<span class="nc" id="L98">			return OptionalInt.empty();</span>
		}
<span class="nc bnc" id="L100" title="All 2 branches missed.">		final int offsetYears = columnHeaderMatcher.group(&quot;yearBefore&quot;) == null ? 0 : -1;</span>
<span class="nc" id="L101">		return OptionalInt.of(Integer.parseInt(yearCell.get()) + offsetYears);</span>
	}

	private static BigDecimal determineValue(final String cellValue, final Account account) {
<span class="nc" id="L105">		final BigDecimal number = new BigDecimal(cellValue);</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">		return account.getType().getSign() &lt; 0 ? number.negate() : number;</span>
	}

	private final int year;
	private final BudgetType type;
	private final Map&lt;Account, Balance&gt; balances = new TreeMap&lt;&gt;();
	private final Map&lt;BudgetReference, String&gt; references = new EnumMap&lt;&gt;(BudgetReference.class);
	private boolean modifiable = true;

	@Override
	public int compareTo(@Nullable final Budget other) {
<span class="nc" id="L117">		return COMPARATOR.compare(this, other);</span>
	}

	public boolean equalsIncludingBalances(final Budget other) {
<span class="nc bnc" id="L121" title="All 6 branches missed.">		return equals(other) &amp;&amp; containsBalances(other) &amp;&amp; other.containsBalances(this);</span>
	}

	private boolean containsBalances(final Budget other) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">		for (final Entry&lt;Account, Balance&gt; entry : other.getBalances().entrySet()) {</span>
<span class="nc" id="L126">			final BigDecimal otherValue = entry.getValue().getValue();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (otherValue.compareTo(BigDecimal.ZERO) != 0) {</span>
<span class="nc" id="L128">				final Balance thisBalance = getBalances().get(entry.getKey());</span>
<span class="nc bnc" id="L129" title="All 4 branches missed.">				if (thisBalance != null &amp;&amp; thisBalance.getValue().compareTo(otherValue) != 0) {</span>
<span class="nc" id="L130">					return false;</span>
				}
			}
<span class="nc" id="L133">		}</span>
<span class="nc" id="L134">		return true;</span>
	}

	public Map&lt;Account, Balance&gt; getBalances() {
<span class="nc bnc" id="L138" title="All 2 branches missed.">		return modifiable ? balances : unmodifiableMap(balances);</span>
	}

	public Map&lt;BudgetReference, String&gt; getReferences() {
<span class="nc" id="L142">		return unmodifiableMap(references);</span>
	}

	public int removeEmptyBalances() {
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (!modifiable) {</span>
<span class="nc" id="L147">			throw new UnsupportedOperationException();</span>
		}
<span class="nc" id="L149">		int count = 0;</span>
<span class="nc" id="L150">		final Iterator&lt;Balance&gt; iterator = getBalances().values().iterator();</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">		while (iterator.hasNext()) {</span>
<span class="nc" id="L152">			final Balance balance = iterator.next();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (balance.getValue().compareTo(BigDecimal.ZERO) == 0) {</span>
<span class="nc" id="L154">				iterator.remove();</span>
<span class="nc" id="L155">				count += 1;</span>
			}
<span class="nc" id="L157">		}</span>
<span class="nc" id="L158">		return count;</span>
	}

	public void setReference(final BudgetReference reference, final String value) {
<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (!modifiable) {</span>
<span class="nc" id="L163">			throw new UnsupportedOperationException();</span>
		}
<span class="nc" id="L165">		references.put(reference, value);</span>
<span class="nc" id="L166">	}</span>

	public Budget unmodifiable() {
<span class="nc" id="L169">		modifiable = false;</span>
<span class="nc" id="L170">		return this;</span>
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public int getYear() {
		return this.year;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public BudgetType getType() {
		return this.type;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public boolean isModifiable() {
		return this.modifiable;
	}

	@edu.umd.cs.findbugs.annotations.NonNull
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public java.lang.String toString() {
		return &quot;Budget(year=&quot; + this.getYear() + &quot;, type=&quot; + this.getType() + &quot;, references=&quot; + this.getReferences() + &quot;, modifiable=&quot; + this.isModifiable() + &quot;)&quot;;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public boolean equals(@edu.umd.cs.findbugs.annotations.Nullable final java.lang.Object o) {
		if (o == this) return true;
		if (!(o instanceof Budget)) return false;
		final Budget other = (Budget) o;
		if (this.getYear() != other.getYear()) return false;
		final java.lang.Object this$type = this.getType();
		final java.lang.Object other$type = other.getType();
		if (this$type == null ? other$type != null : !this$type.equals(other$type)) return false;
		return true;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		result = result * PRIME + this.getYear();
		final java.lang.Object $type = this.getType();
		result = result * PRIME + ($type == null ? 43 : $type.hashCode());
		return result;
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(justification = &quot;generated code&quot;)
	@lombok.Generated
	private Budget(final int year, final BudgetType type) {
		this.year = year;
		this.type = type;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>